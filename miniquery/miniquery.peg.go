package miniquery

// Code generated by peg -switch miniquery.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleGrammar
	ruleExpression
	ruleLogicExpression
	ruleNotExpression
	ruleCompareExpression
	ruleCompareInExpression
	rulePredicateExpression
	ruleBetweenExpression
	rulePrimaryExpression
	ruleArgumentList
	ruleArgument
	ruleReference
	ruleIdentifierReference
	ruleJsonReference
	ruleIdentifier
	ruleCompare
	ruleLogic
	ruleMatch
	ruleValue
	ruleArray
	ruleLiteral
	ruleInteger
	ruleBoolean
	ruleNull
	ruleString
	ruleSpaceComment
	rule_
	rule__
	ruleComment
	ruleSpace
	ruleEndOfLine
	ruleEndOfFile
	ruleAction0
	ruleAction1
	ruleAction2
	rulePegText
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
)

var rul3s = [...]string{
	"Unknown",
	"Grammar",
	"Expression",
	"LogicExpression",
	"NotExpression",
	"CompareExpression",
	"CompareInExpression",
	"PredicateExpression",
	"BetweenExpression",
	"PrimaryExpression",
	"ArgumentList",
	"Argument",
	"Reference",
	"IdentifierReference",
	"JsonReference",
	"Identifier",
	"Compare",
	"Logic",
	"Match",
	"Value",
	"Array",
	"Literal",
	"Integer",
	"Boolean",
	"Null",
	"String",
	"SpaceComment",
	"_",
	"__",
	"Comment",
	"Space",
	"EndOfLine",
	"EndOfFile",
	"Action0",
	"Action1",
	"Action2",
	"PegText",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type MiniQueryPeg struct {
	*Tree

	Buffer string
	buffer []rune
	rules  [64]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *MiniQueryPeg) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *MiniQueryPeg) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *MiniQueryPeg
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *MiniQueryPeg) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *MiniQueryPeg) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *MiniQueryPeg) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *MiniQueryPeg) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.PopLogic()
		case ruleAction1:
			p.PopNot()
		case ruleAction2:
			p.PopCompare()
		case ruleAction3:
			p.AddCompare(text)
		case ruleAction4:
			p.PopCompare()
		case ruleAction5:
			p.PopPredicate()
		case ruleAction6:
			p.AddOperation(text)
		case ruleAction7:
			p.PopBetween()
		case ruleAction8:
			p.PopParentheses()
		case ruleAction9:
			p.PopFunction()
		case ruleAction10:
			p.AddMark()
		case ruleAction11:
			p.PopArray()
		case ruleAction12:
			p.AddMark()
		case ruleAction13:
			p.PopIdentifierReference()
		case ruleAction14:
			p.AddName(text)
		case ruleAction15:
			p.AddCompare(text)
		case ruleAction16:
			p.AddCompare(text)
		case ruleAction17:
			p.AddCompare(text)
		case ruleAction18:
			p.AddLogic(text)
		case ruleAction19:
			p.AddLogic(text)
		case ruleAction20:
			p.AddMatch(text)
		case ruleAction21:
			p.AddMark()
		case ruleAction22:
			p.PopArray()
		case ruleAction23:
			p.AddMark()
		case ruleAction24:
			p.PopArray()
		case ruleAction25:
			p.AddInteger(text)
		case ruleAction26:
			p.AddBoolean(text)
		case ruleAction27:
			p.AddNull()
		case ruleAction28:
			p.AddString(text)
		case ruleAction29:
			p.AddString(text)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*MiniQueryPeg) error {
	return func(p *MiniQueryPeg) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*MiniQueryPeg) error {
	return func(p *MiniQueryPeg) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}

func (p *MiniQueryPeg) Init(options ...func(*MiniQueryPeg) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Grammar <- <(_ Expression _ EndOfFile)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
				if !_rules[ruleExpression]() {
					goto l0
				}
				if !_rules[rule_]() {
					goto l0
				}
				if !_rules[ruleEndOfFile]() {
					goto l0
				}
				add(ruleGrammar, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <LogicExpression> */
		func() bool {
			position2, tokenIndex2 := position, tokenIndex
			{
				position3 := position
				if !_rules[ruleLogicExpression]() {
					goto l2
				}
				add(ruleExpression, position3)
			}
			return true
		l2:
			position, tokenIndex = position2, tokenIndex2
			return false
		},
		/* 2 LogicExpression <- <(NotExpression (Logic NotExpression Action0)*)> */
		func() bool {
			position4, tokenIndex4 := position, tokenIndex
			{
				position5 := position
				if !_rules[ruleNotExpression]() {
					goto l4
				}
			l6:
				{
					position7, tokenIndex7 := position, tokenIndex
					if !_rules[ruleLogic]() {
						goto l7
					}
					if !_rules[ruleNotExpression]() {
						goto l7
					}
					if !_rules[ruleAction0]() {
						goto l7
					}
					goto l6
				l7:
					position, tokenIndex = position7, tokenIndex7
				}
				add(ruleLogicExpression, position5)
			}
			return true
		l4:
			position, tokenIndex = position4, tokenIndex4
			return false
		},
		/* 3 NotExpression <- <(CompareExpression / (_ (('n' / 'N') ('o' / 'O') ('t' / 'T')) __ CompareExpression Action1))> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					if !_rules[ruleCompareExpression]() {
						goto l11
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rule_]() {
						goto l8
					}
					{
						position12, tokenIndex12 := position, tokenIndex
						if buffer[position] != rune('n') {
							goto l13
						}
						position++
						goto l12
					l13:
						position, tokenIndex = position12, tokenIndex12
						if buffer[position] != rune('N') {
							goto l8
						}
						position++
					}
				l12:
					{
						position14, tokenIndex14 := position, tokenIndex
						if buffer[position] != rune('o') {
							goto l15
						}
						position++
						goto l14
					l15:
						position, tokenIndex = position14, tokenIndex14
						if buffer[position] != rune('O') {
							goto l8
						}
						position++
					}
				l14:
					{
						position16, tokenIndex16 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l17
						}
						position++
						goto l16
					l17:
						position, tokenIndex = position16, tokenIndex16
						if buffer[position] != rune('T') {
							goto l8
						}
						position++
					}
				l16:
					if !_rules[rule__]() {
						goto l8
					}
					if !_rules[ruleCompareExpression]() {
						goto l8
					}
					if !_rules[ruleAction1]() {
						goto l8
					}
				}
			l10:
				add(ruleNotExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 4 CompareExpression <- <(CompareInExpression (Compare CompareInExpression Action2)*)> */
		func() bool {
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				if !_rules[ruleCompareInExpression]() {
					goto l18
				}
			l20:
				{
					position21, tokenIndex21 := position, tokenIndex
					if !_rules[ruleCompare]() {
						goto l21
					}
					if !_rules[ruleCompareInExpression]() {
						goto l21
					}
					if !_rules[ruleAction2]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position21, tokenIndex21
				}
				add(ruleCompareExpression, position19)
			}
			return true
		l18:
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 5 CompareInExpression <- <(PredicateExpression (_ <((('i' / 'I') ('n' / 'N')) / (('n' / 'N') ('o' / 'O') ('t' / 'T') __ (('i' / 'I') ('n' / 'N'))))> _ Action3 Array Action4)?)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				if !_rules[rulePredicateExpression]() {
					goto l22
				}
				{
					position24, tokenIndex24 := position, tokenIndex
					if !_rules[rule_]() {
						goto l24
					}
					{
						position26 := position
						{
							position27, tokenIndex27 := position, tokenIndex
							{
								position29, tokenIndex29 := position, tokenIndex
								if buffer[position] != rune('i') {
									goto l30
								}
								position++
								goto l29
							l30:
								position, tokenIndex = position29, tokenIndex29
								if buffer[position] != rune('I') {
									goto l28
								}
								position++
							}
						l29:
							{
								position31, tokenIndex31 := position, tokenIndex
								if buffer[position] != rune('n') {
									goto l32
								}
								position++
								goto l31
							l32:
								position, tokenIndex = position31, tokenIndex31
								if buffer[position] != rune('N') {
									goto l28
								}
								position++
							}
						l31:
							goto l27
						l28:
							position, tokenIndex = position27, tokenIndex27
							{
								position33, tokenIndex33 := position, tokenIndex
								if buffer[position] != rune('n') {
									goto l34
								}
								position++
								goto l33
							l34:
								position, tokenIndex = position33, tokenIndex33
								if buffer[position] != rune('N') {
									goto l24
								}
								position++
							}
						l33:
							{
								position35, tokenIndex35 := position, tokenIndex
								if buffer[position] != rune('o') {
									goto l36
								}
								position++
								goto l35
							l36:
								position, tokenIndex = position35, tokenIndex35
								if buffer[position] != rune('O') {
									goto l24
								}
								position++
							}
						l35:
							{
								position37, tokenIndex37 := position, tokenIndex
								if buffer[position] != rune('t') {
									goto l38
								}
								position++
								goto l37
							l38:
								position, tokenIndex = position37, tokenIndex37
								if buffer[position] != rune('T') {
									goto l24
								}
								position++
							}
						l37:
							if !_rules[rule__]() {
								goto l24
							}
							{
								position39, tokenIndex39 := position, tokenIndex
								if buffer[position] != rune('i') {
									goto l40
								}
								position++
								goto l39
							l40:
								position, tokenIndex = position39, tokenIndex39
								if buffer[position] != rune('I') {
									goto l24
								}
								position++
							}
						l39:
							{
								position41, tokenIndex41 := position, tokenIndex
								if buffer[position] != rune('n') {
									goto l42
								}
								position++
								goto l41
							l42:
								position, tokenIndex = position41, tokenIndex41
								if buffer[position] != rune('N') {
									goto l24
								}
								position++
							}
						l41:
						}
					l27:
						add(rulePegText, position26)
					}
					if !_rules[rule_]() {
						goto l24
					}
					if !_rules[ruleAction3]() {
						goto l24
					}
					if !_rules[ruleArray]() {
						goto l24
					}
					if !_rules[ruleAction4]() {
						goto l24
					}
					goto l25
				l24:
					position, tokenIndex = position24, tokenIndex24
				}
			l25:
				add(ruleCompareInExpression, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 6 PredicateExpression <- <(BetweenExpression (Match Action5)?)> */
		func() bool {
			position43, tokenIndex43 := position, tokenIndex
			{
				position44 := position
				if !_rules[ruleBetweenExpression]() {
					goto l43
				}
				{
					position45, tokenIndex45 := position, tokenIndex
					if !_rules[ruleMatch]() {
						goto l45
					}
					if !_rules[ruleAction5]() {
						goto l45
					}
					goto l46
				l45:
					position, tokenIndex = position45, tokenIndex45
				}
			l46:
				add(rulePredicateExpression, position44)
			}
			return true
		l43:
			position, tokenIndex = position43, tokenIndex43
			return false
		},
		/* 7 BetweenExpression <- <(PrimaryExpression (_ <((('n' / 'N') ('o' / 'O') ('t' / 'T') __)? ('b' 'e' 't' 'w' 'e' 'e' 'n'))> Action6 _ ((Value _ (('a' / 'A') ('n' / 'N') ('d' / 'D')) _ Value) / ('[' _ Value _ ',' _ Value _ ']')) Action7)?)> */
		func() bool {
			position47, tokenIndex47 := position, tokenIndex
			{
				position48 := position
				if !_rules[rulePrimaryExpression]() {
					goto l47
				}
				{
					position49, tokenIndex49 := position, tokenIndex
					if !_rules[rule_]() {
						goto l49
					}
					{
						position51 := position
						{
							position52, tokenIndex52 := position, tokenIndex
							{
								position54, tokenIndex54 := position, tokenIndex
								if buffer[position] != rune('n') {
									goto l55
								}
								position++
								goto l54
							l55:
								position, tokenIndex = position54, tokenIndex54
								if buffer[position] != rune('N') {
									goto l52
								}
								position++
							}
						l54:
							{
								position56, tokenIndex56 := position, tokenIndex
								if buffer[position] != rune('o') {
									goto l57
								}
								position++
								goto l56
							l57:
								position, tokenIndex = position56, tokenIndex56
								if buffer[position] != rune('O') {
									goto l52
								}
								position++
							}
						l56:
							{
								position58, tokenIndex58 := position, tokenIndex
								if buffer[position] != rune('t') {
									goto l59
								}
								position++
								goto l58
							l59:
								position, tokenIndex = position58, tokenIndex58
								if buffer[position] != rune('T') {
									goto l52
								}
								position++
							}
						l58:
							if !_rules[rule__]() {
								goto l52
							}
							goto l53
						l52:
							position, tokenIndex = position52, tokenIndex52
						}
					l53:
						if buffer[position] != rune('b') {
							goto l49
						}
						position++
						if buffer[position] != rune('e') {
							goto l49
						}
						position++
						if buffer[position] != rune('t') {
							goto l49
						}
						position++
						if buffer[position] != rune('w') {
							goto l49
						}
						position++
						if buffer[position] != rune('e') {
							goto l49
						}
						position++
						if buffer[position] != rune('e') {
							goto l49
						}
						position++
						if buffer[position] != rune('n') {
							goto l49
						}
						position++
						add(rulePegText, position51)
					}
					if !_rules[ruleAction6]() {
						goto l49
					}
					if !_rules[rule_]() {
						goto l49
					}
					{
						position60, tokenIndex60 := position, tokenIndex
						if !_rules[ruleValue]() {
							goto l61
						}
						if !_rules[rule_]() {
							goto l61
						}
						{
							position62, tokenIndex62 := position, tokenIndex
							if buffer[position] != rune('a') {
								goto l63
							}
							position++
							goto l62
						l63:
							position, tokenIndex = position62, tokenIndex62
							if buffer[position] != rune('A') {
								goto l61
							}
							position++
						}
					l62:
						{
							position64, tokenIndex64 := position, tokenIndex
							if buffer[position] != rune('n') {
								goto l65
							}
							position++
							goto l64
						l65:
							position, tokenIndex = position64, tokenIndex64
							if buffer[position] != rune('N') {
								goto l61
							}
							position++
						}
					l64:
						{
							position66, tokenIndex66 := position, tokenIndex
							if buffer[position] != rune('d') {
								goto l67
							}
							position++
							goto l66
						l67:
							position, tokenIndex = position66, tokenIndex66
							if buffer[position] != rune('D') {
								goto l61
							}
							position++
						}
					l66:
						if !_rules[rule_]() {
							goto l61
						}
						if !_rules[ruleValue]() {
							goto l61
						}
						goto l60
					l61:
						position, tokenIndex = position60, tokenIndex60
						if buffer[position] != rune('[') {
							goto l49
						}
						position++
						if !_rules[rule_]() {
							goto l49
						}
						if !_rules[ruleValue]() {
							goto l49
						}
						if !_rules[rule_]() {
							goto l49
						}
						if buffer[position] != rune(',') {
							goto l49
						}
						position++
						if !_rules[rule_]() {
							goto l49
						}
						if !_rules[ruleValue]() {
							goto l49
						}
						if !_rules[rule_]() {
							goto l49
						}
						if buffer[position] != rune(']') {
							goto l49
						}
						position++
					}
				l60:
					if !_rules[ruleAction7]() {
						goto l49
					}
					goto l50
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
			l50:
				add(ruleBetweenExpression, position48)
			}
			return true
		l47:
			position, tokenIndex = position47, tokenIndex47
			return false
		},
		/* 8 PrimaryExpression <- <(('(' _ Expression _ ')' Action8) / Value / (Identifier ArgumentList Action9) / Reference)> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				{
					position70, tokenIndex70 := position, tokenIndex
					if buffer[position] != rune('(') {
						goto l71
					}
					position++
					if !_rules[rule_]() {
						goto l71
					}
					if !_rules[ruleExpression]() {
						goto l71
					}
					if !_rules[rule_]() {
						goto l71
					}
					if buffer[position] != rune(')') {
						goto l71
					}
					position++
					if !_rules[ruleAction8]() {
						goto l71
					}
					goto l70
				l71:
					position, tokenIndex = position70, tokenIndex70
					if !_rules[ruleValue]() {
						goto l72
					}
					goto l70
				l72:
					position, tokenIndex = position70, tokenIndex70
					if !_rules[ruleIdentifier]() {
						goto l73
					}
					if !_rules[ruleArgumentList]() {
						goto l73
					}
					if !_rules[ruleAction9]() {
						goto l73
					}
					goto l70
				l73:
					position, tokenIndex = position70, tokenIndex70
					if !_rules[ruleReference]() {
						goto l68
					}
				}
			l70:
				add(rulePrimaryExpression, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 9 ArgumentList <- <('(' _ Action10 (Argument (_ ',' _ Argument)* _ ','?)? _ ')' Action11)> */
		func() bool {
			position74, tokenIndex74 := position, tokenIndex
			{
				position75 := position
				if buffer[position] != rune('(') {
					goto l74
				}
				position++
				if !_rules[rule_]() {
					goto l74
				}
				if !_rules[ruleAction10]() {
					goto l74
				}
				{
					position76, tokenIndex76 := position, tokenIndex
					if !_rules[ruleArgument]() {
						goto l76
					}
				l78:
					{
						position79, tokenIndex79 := position, tokenIndex
						if !_rules[rule_]() {
							goto l79
						}
						if buffer[position] != rune(',') {
							goto l79
						}
						position++
						if !_rules[rule_]() {
							goto l79
						}
						if !_rules[ruleArgument]() {
							goto l79
						}
						goto l78
					l79:
						position, tokenIndex = position79, tokenIndex79
					}
					if !_rules[rule_]() {
						goto l76
					}
					{
						position80, tokenIndex80 := position, tokenIndex
						if buffer[position] != rune(',') {
							goto l80
						}
						position++
						goto l81
					l80:
						position, tokenIndex = position80, tokenIndex80
					}
				l81:
					goto l77
				l76:
					position, tokenIndex = position76, tokenIndex76
				}
			l77:
				if !_rules[rule_]() {
					goto l74
				}
				if buffer[position] != rune(')') {
					goto l74
				}
				position++
				if !_rules[ruleAction11]() {
					goto l74
				}
				add(ruleArgumentList, position75)
			}
			return true
		l74:
			position, tokenIndex = position74, tokenIndex74
			return false
		},
		/* 10 Argument <- <Expression> */
		func() bool {
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				if !_rules[ruleExpression]() {
					goto l82
				}
				add(ruleArgument, position83)
			}
			return true
		l82:
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 11 Reference <- <(IdentifierReference / JsonReference / Identifier)> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				{
					position86, tokenIndex86 := position, tokenIndex
					if !_rules[ruleIdentifierReference]() {
						goto l87
					}
					goto l86
				l87:
					position, tokenIndex = position86, tokenIndex86
					if !_rules[ruleJsonReference]() {
						goto l88
					}
					goto l86
				l88:
					position, tokenIndex = position86, tokenIndex86
					if !_rules[ruleIdentifier]() {
						goto l84
					}
				}
			l86:
				add(ruleReference, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 12 IdentifierReference <- <(Action12 Identifier '.' Identifier ('.' Identifier)* Action13)> */
		func() bool {
			position89, tokenIndex89 := position, tokenIndex
			{
				position90 := position
				if !_rules[ruleAction12]() {
					goto l89
				}
				if !_rules[ruleIdentifier]() {
					goto l89
				}
				if buffer[position] != rune('.') {
					goto l89
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l89
				}
			l91:
				{
					position92, tokenIndex92 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l92
					}
					position++
					if !_rules[ruleIdentifier]() {
						goto l92
					}
					goto l91
				l92:
					position, tokenIndex = position92, tokenIndex92
				}
				if !_rules[ruleAction13]() {
					goto l89
				}
				add(ruleIdentifierReference, position90)
			}
			return true
		l89:
			position, tokenIndex = position89, tokenIndex89
			return false
		},
		/* 13 JsonReference <- <(Identifier ('-' '>') (JsonReference / Identifier))> */
		func() bool {
			position93, tokenIndex93 := position, tokenIndex
			{
				position94 := position
				if !_rules[ruleIdentifier]() {
					goto l93
				}
				if buffer[position] != rune('-') {
					goto l93
				}
				position++
				if buffer[position] != rune('>') {
					goto l93
				}
				position++
				{
					position95, tokenIndex95 := position, tokenIndex
					if !_rules[ruleJsonReference]() {
						goto l96
					}
					goto l95
				l96:
					position, tokenIndex = position95, tokenIndex95
					if !_rules[ruleIdentifier]() {
						goto l93
					}
				}
			l95:
				add(ruleJsonReference, position94)
			}
			return true
		l93:
			position, tokenIndex = position93, tokenIndex93
			return false
		},
		/* 14 Identifier <- <(!(('n' / 'N') ('o' / 'O') ('t' / 'T')) <(([a-z] / [A-Z]) ((&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('_') '_') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))*)> Action14)> */
		func() bool {
			position97, tokenIndex97 := position, tokenIndex
			{
				position98 := position
				{
					position99, tokenIndex99 := position, tokenIndex
					{
						position100, tokenIndex100 := position, tokenIndex
						if buffer[position] != rune('n') {
							goto l101
						}
						position++
						goto l100
					l101:
						position, tokenIndex = position100, tokenIndex100
						if buffer[position] != rune('N') {
							goto l99
						}
						position++
					}
				l100:
					{
						position102, tokenIndex102 := position, tokenIndex
						if buffer[position] != rune('o') {
							goto l103
						}
						position++
						goto l102
					l103:
						position, tokenIndex = position102, tokenIndex102
						if buffer[position] != rune('O') {
							goto l99
						}
						position++
					}
				l102:
					{
						position104, tokenIndex104 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l105
						}
						position++
						goto l104
					l105:
						position, tokenIndex = position104, tokenIndex104
						if buffer[position] != rune('T') {
							goto l99
						}
						position++
					}
				l104:
					goto l97
				l99:
					position, tokenIndex = position99, tokenIndex99
				}
				{
					position106 := position
					{
						position107, tokenIndex107 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l108
						}
						position++
						goto l107
					l108:
						position, tokenIndex = position107, tokenIndex107
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l97
						}
						position++
					}
				l107:
				l109:
					{
						position110, tokenIndex110 := position, tokenIndex
						{
							switch buffer[position] {
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l110
								}
								position++
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								if c := buffer[position]; c < rune('A') || c > rune('Z') {
									goto l110
								}
								position++
							case '_':
								if buffer[position] != rune('_') {
									goto l110
								}
								position++
							default:
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l110
								}
								position++
							}
						}

						goto l109
					l110:
						position, tokenIndex = position110, tokenIndex110
					}
					add(rulePegText, position106)
				}
				if !_rules[ruleAction14]() {
					goto l97
				}
				add(ruleIdentifier, position98)
			}
			return true
		l97:
			position, tokenIndex = position97, tokenIndex97
			return false
		},
		/* 15 Compare <- <((_ <(('>' '=') / ('<' '=') / ('=' '=') / '<' / ((&('=') '=') | (&('<') ('<' '>')) | (&('>') '>') | (&('!') ('!' '='))))> _ Action15) / (_ <((('g' / 'G') ('t' / 'T')) / (('l' / 'L') ('t' / 'T')) / ((&('N' | 'n') (('n' / 'N') ('e' / 'E') ('q' / 'Q'))) | (&('E' | 'e') (('e' / 'E') ('q' / 'Q'))) | (&('L' | 'l') (('l' / 'L') ('t' / 'T') ('e' / 'E'))) | (&('G' | 'g') (('g' / 'G') ('t' / 'T') ('e' / 'E')))))> _ Action16) / (_ <((('l' / 'L') ('i' / 'I') ('k' / 'K') ('e' / 'E')) / (('n' / 'N') ('o' / 'O') ('t' / 'T') __ (('l' / 'L') ('i' / 'I') ('k' / 'K') ('e' / 'E'))))> _ Action17))> */
		func() bool {
			position112, tokenIndex112 := position, tokenIndex
			{
				position113 := position
				{
					position114, tokenIndex114 := position, tokenIndex
					if !_rules[rule_]() {
						goto l115
					}
					{
						position116 := position
						{
							position117, tokenIndex117 := position, tokenIndex
							if buffer[position] != rune('>') {
								goto l118
							}
							position++
							if buffer[position] != rune('=') {
								goto l118
							}
							position++
							goto l117
						l118:
							position, tokenIndex = position117, tokenIndex117
							if buffer[position] != rune('<') {
								goto l119
							}
							position++
							if buffer[position] != rune('=') {
								goto l119
							}
							position++
							goto l117
						l119:
							position, tokenIndex = position117, tokenIndex117
							if buffer[position] != rune('=') {
								goto l120
							}
							position++
							if buffer[position] != rune('=') {
								goto l120
							}
							position++
							goto l117
						l120:
							position, tokenIndex = position117, tokenIndex117
							if buffer[position] != rune('<') {
								goto l121
							}
							position++
							goto l117
						l121:
							position, tokenIndex = position117, tokenIndex117
							{
								switch buffer[position] {
								case '=':
									if buffer[position] != rune('=') {
										goto l115
									}
									position++
								case '<':
									if buffer[position] != rune('<') {
										goto l115
									}
									position++
									if buffer[position] != rune('>') {
										goto l115
									}
									position++
								case '>':
									if buffer[position] != rune('>') {
										goto l115
									}
									position++
								default:
									if buffer[position] != rune('!') {
										goto l115
									}
									position++
									if buffer[position] != rune('=') {
										goto l115
									}
									position++
								}
							}

						}
					l117:
						add(rulePegText, position116)
					}
					if !_rules[rule_]() {
						goto l115
					}
					if !_rules[ruleAction15]() {
						goto l115
					}
					goto l114
				l115:
					position, tokenIndex = position114, tokenIndex114
					if !_rules[rule_]() {
						goto l123
					}
					{
						position124 := position
						{
							position125, tokenIndex125 := position, tokenIndex
							{
								position127, tokenIndex127 := position, tokenIndex
								if buffer[position] != rune('g') {
									goto l128
								}
								position++
								goto l127
							l128:
								position, tokenIndex = position127, tokenIndex127
								if buffer[position] != rune('G') {
									goto l126
								}
								position++
							}
						l127:
							{
								position129, tokenIndex129 := position, tokenIndex
								if buffer[position] != rune('t') {
									goto l130
								}
								position++
								goto l129
							l130:
								position, tokenIndex = position129, tokenIndex129
								if buffer[position] != rune('T') {
									goto l126
								}
								position++
							}
						l129:
							goto l125
						l126:
							position, tokenIndex = position125, tokenIndex125
							{
								position132, tokenIndex132 := position, tokenIndex
								if buffer[position] != rune('l') {
									goto l133
								}
								position++
								goto l132
							l133:
								position, tokenIndex = position132, tokenIndex132
								if buffer[position] != rune('L') {
									goto l131
								}
								position++
							}
						l132:
							{
								position134, tokenIndex134 := position, tokenIndex
								if buffer[position] != rune('t') {
									goto l135
								}
								position++
								goto l134
							l135:
								position, tokenIndex = position134, tokenIndex134
								if buffer[position] != rune('T') {
									goto l131
								}
								position++
							}
						l134:
							goto l125
						l131:
							position, tokenIndex = position125, tokenIndex125
							{
								switch buffer[position] {
								case 'N', 'n':
									{
										position137, tokenIndex137 := position, tokenIndex
										if buffer[position] != rune('n') {
											goto l138
										}
										position++
										goto l137
									l138:
										position, tokenIndex = position137, tokenIndex137
										if buffer[position] != rune('N') {
											goto l123
										}
										position++
									}
								l137:
									{
										position139, tokenIndex139 := position, tokenIndex
										if buffer[position] != rune('e') {
											goto l140
										}
										position++
										goto l139
									l140:
										position, tokenIndex = position139, tokenIndex139
										if buffer[position] != rune('E') {
											goto l123
										}
										position++
									}
								l139:
									{
										position141, tokenIndex141 := position, tokenIndex
										if buffer[position] != rune('q') {
											goto l142
										}
										position++
										goto l141
									l142:
										position, tokenIndex = position141, tokenIndex141
										if buffer[position] != rune('Q') {
											goto l123
										}
										position++
									}
								l141:
									break
								case 'E', 'e':
									{
										position143, tokenIndex143 := position, tokenIndex
										if buffer[position] != rune('e') {
											goto l144
										}
										position++
										goto l143
									l144:
										position, tokenIndex = position143, tokenIndex143
										if buffer[position] != rune('E') {
											goto l123
										}
										position++
									}
								l143:
									{
										position145, tokenIndex145 := position, tokenIndex
										if buffer[position] != rune('q') {
											goto l146
										}
										position++
										goto l145
									l146:
										position, tokenIndex = position145, tokenIndex145
										if buffer[position] != rune('Q') {
											goto l123
										}
										position++
									}
								l145:
									break
								case 'L', 'l':
									{
										position147, tokenIndex147 := position, tokenIndex
										if buffer[position] != rune('l') {
											goto l148
										}
										position++
										goto l147
									l148:
										position, tokenIndex = position147, tokenIndex147
										if buffer[position] != rune('L') {
											goto l123
										}
										position++
									}
								l147:
									{
										position149, tokenIndex149 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l150
										}
										position++
										goto l149
									l150:
										position, tokenIndex = position149, tokenIndex149
										if buffer[position] != rune('T') {
											goto l123
										}
										position++
									}
								l149:
									{
										position151, tokenIndex151 := position, tokenIndex
										if buffer[position] != rune('e') {
											goto l152
										}
										position++
										goto l151
									l152:
										position, tokenIndex = position151, tokenIndex151
										if buffer[position] != rune('E') {
											goto l123
										}
										position++
									}
								l151:
									break
								default:
									{
										position153, tokenIndex153 := position, tokenIndex
										if buffer[position] != rune('g') {
											goto l154
										}
										position++
										goto l153
									l154:
										position, tokenIndex = position153, tokenIndex153
										if buffer[position] != rune('G') {
											goto l123
										}
										position++
									}
								l153:
									{
										position155, tokenIndex155 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l156
										}
										position++
										goto l155
									l156:
										position, tokenIndex = position155, tokenIndex155
										if buffer[position] != rune('T') {
											goto l123
										}
										position++
									}
								l155:
									{
										position157, tokenIndex157 := position, tokenIndex
										if buffer[position] != rune('e') {
											goto l158
										}
										position++
										goto l157
									l158:
										position, tokenIndex = position157, tokenIndex157
										if buffer[position] != rune('E') {
											goto l123
										}
										position++
									}
								l157:
									break
								}
							}

						}
					l125:
						add(rulePegText, position124)
					}
					if !_rules[rule_]() {
						goto l123
					}
					if !_rules[ruleAction16]() {
						goto l123
					}
					goto l114
				l123:
					position, tokenIndex = position114, tokenIndex114
					if !_rules[rule_]() {
						goto l112
					}
					{
						position159 := position
						{
							position160, tokenIndex160 := position, tokenIndex
							{
								position162, tokenIndex162 := position, tokenIndex
								if buffer[position] != rune('l') {
									goto l163
								}
								position++
								goto l162
							l163:
								position, tokenIndex = position162, tokenIndex162
								if buffer[position] != rune('L') {
									goto l161
								}
								position++
							}
						l162:
							{
								position164, tokenIndex164 := position, tokenIndex
								if buffer[position] != rune('i') {
									goto l165
								}
								position++
								goto l164
							l165:
								position, tokenIndex = position164, tokenIndex164
								if buffer[position] != rune('I') {
									goto l161
								}
								position++
							}
						l164:
							{
								position166, tokenIndex166 := position, tokenIndex
								if buffer[position] != rune('k') {
									goto l167
								}
								position++
								goto l166
							l167:
								position, tokenIndex = position166, tokenIndex166
								if buffer[position] != rune('K') {
									goto l161
								}
								position++
							}
						l166:
							{
								position168, tokenIndex168 := position, tokenIndex
								if buffer[position] != rune('e') {
									goto l169
								}
								position++
								goto l168
							l169:
								position, tokenIndex = position168, tokenIndex168
								if buffer[position] != rune('E') {
									goto l161
								}
								position++
							}
						l168:
							goto l160
						l161:
							position, tokenIndex = position160, tokenIndex160
							{
								position170, tokenIndex170 := position, tokenIndex
								if buffer[position] != rune('n') {
									goto l171
								}
								position++
								goto l170
							l171:
								position, tokenIndex = position170, tokenIndex170
								if buffer[position] != rune('N') {
									goto l112
								}
								position++
							}
						l170:
							{
								position172, tokenIndex172 := position, tokenIndex
								if buffer[position] != rune('o') {
									goto l173
								}
								position++
								goto l172
							l173:
								position, tokenIndex = position172, tokenIndex172
								if buffer[position] != rune('O') {
									goto l112
								}
								position++
							}
						l172:
							{
								position174, tokenIndex174 := position, tokenIndex
								if buffer[position] != rune('t') {
									goto l175
								}
								position++
								goto l174
							l175:
								position, tokenIndex = position174, tokenIndex174
								if buffer[position] != rune('T') {
									goto l112
								}
								position++
							}
						l174:
							if !_rules[rule__]() {
								goto l112
							}
							{
								position176, tokenIndex176 := position, tokenIndex
								if buffer[position] != rune('l') {
									goto l177
								}
								position++
								goto l176
							l177:
								position, tokenIndex = position176, tokenIndex176
								if buffer[position] != rune('L') {
									goto l112
								}
								position++
							}
						l176:
							{
								position178, tokenIndex178 := position, tokenIndex
								if buffer[position] != rune('i') {
									goto l179
								}
								position++
								goto l178
							l179:
								position, tokenIndex = position178, tokenIndex178
								if buffer[position] != rune('I') {
									goto l112
								}
								position++
							}
						l178:
							{
								position180, tokenIndex180 := position, tokenIndex
								if buffer[position] != rune('k') {
									goto l181
								}
								position++
								goto l180
							l181:
								position, tokenIndex = position180, tokenIndex180
								if buffer[position] != rune('K') {
									goto l112
								}
								position++
							}
						l180:
							{
								position182, tokenIndex182 := position, tokenIndex
								if buffer[position] != rune('e') {
									goto l183
								}
								position++
								goto l182
							l183:
								position, tokenIndex = position182, tokenIndex182
								if buffer[position] != rune('E') {
									goto l112
								}
								position++
							}
						l182:
						}
					l160:
						add(rulePegText, position159)
					}
					if !_rules[rule_]() {
						goto l112
					}
					if !_rules[ruleAction17]() {
						goto l112
					}
				}
			l114:
				add(ruleCompare, position113)
			}
			return true
		l112:
			position, tokenIndex = position112, tokenIndex112
			return false
		},
		/* 16 Logic <- <((_ <((('a' / 'A') ('n' / 'N') ('d' / 'D')) / (('o' / 'O') ('r' / 'R')))> _ Action18) / (_ <(('&' '&') / ('|' '|'))> _ Action19))> */
		func() bool {
			position184, tokenIndex184 := position, tokenIndex
			{
				position185 := position
				{
					position186, tokenIndex186 := position, tokenIndex
					if !_rules[rule_]() {
						goto l187
					}
					{
						position188 := position
						{
							position189, tokenIndex189 := position, tokenIndex
							{
								position191, tokenIndex191 := position, tokenIndex
								if buffer[position] != rune('a') {
									goto l192
								}
								position++
								goto l191
							l192:
								position, tokenIndex = position191, tokenIndex191
								if buffer[position] != rune('A') {
									goto l190
								}
								position++
							}
						l191:
							{
								position193, tokenIndex193 := position, tokenIndex
								if buffer[position] != rune('n') {
									goto l194
								}
								position++
								goto l193
							l194:
								position, tokenIndex = position193, tokenIndex193
								if buffer[position] != rune('N') {
									goto l190
								}
								position++
							}
						l193:
							{
								position195, tokenIndex195 := position, tokenIndex
								if buffer[position] != rune('d') {
									goto l196
								}
								position++
								goto l195
							l196:
								position, tokenIndex = position195, tokenIndex195
								if buffer[position] != rune('D') {
									goto l190
								}
								position++
							}
						l195:
							goto l189
						l190:
							position, tokenIndex = position189, tokenIndex189
							{
								position197, tokenIndex197 := position, tokenIndex
								if buffer[position] != rune('o') {
									goto l198
								}
								position++
								goto l197
							l198:
								position, tokenIndex = position197, tokenIndex197
								if buffer[position] != rune('O') {
									goto l187
								}
								position++
							}
						l197:
							{
								position199, tokenIndex199 := position, tokenIndex
								if buffer[position] != rune('r') {
									goto l200
								}
								position++
								goto l199
							l200:
								position, tokenIndex = position199, tokenIndex199
								if buffer[position] != rune('R') {
									goto l187
								}
								position++
							}
						l199:
						}
					l189:
						add(rulePegText, position188)
					}
					if !_rules[rule_]() {
						goto l187
					}
					if !_rules[ruleAction18]() {
						goto l187
					}
					goto l186
				l187:
					position, tokenIndex = position186, tokenIndex186
					if !_rules[rule_]() {
						goto l184
					}
					{
						position201 := position
						{
							position202, tokenIndex202 := position, tokenIndex
							if buffer[position] != rune('&') {
								goto l203
							}
							position++
							if buffer[position] != rune('&') {
								goto l203
							}
							position++
							goto l202
						l203:
							position, tokenIndex = position202, tokenIndex202
							if buffer[position] != rune('|') {
								goto l184
							}
							position++
							if buffer[position] != rune('|') {
								goto l184
							}
							position++
						}
					l202:
						add(rulePegText, position201)
					}
					if !_rules[rule_]() {
						goto l184
					}
					if !_rules[ruleAction19]() {
						goto l184
					}
				}
			l186:
				add(ruleLogic, position185)
			}
			return true
		l184:
			position, tokenIndex = position184, tokenIndex184
			return false
		},
		/* 17 Match <- <(__ <(('i' 's' 'n' 'u' 'l' 'l') / ('n' 'o' 't' 'n' 'u' 'l' 'l') / ('i' 's' __ ((&('n') ('n' 'u' 'l' 'l')) | (&('f') ('f' 'a' 'l' 's' 'e')) | (&('t') ('t' 'r' 'u' 'e')))) / ('i' 's' __ ('n' 'o' 't') __ ((&('n') ('n' 'u' 'l' 'l')) | (&('f') ('f' 'a' 'l' 's' 'e')) | (&('t') ('t' 'r' 'u' 'e')))))> _ Action20)> */
		func() bool {
			position204, tokenIndex204 := position, tokenIndex
			{
				position205 := position
				if !_rules[rule__]() {
					goto l204
				}
				{
					position206 := position
					{
						position207, tokenIndex207 := position, tokenIndex
						if buffer[position] != rune('i') {
							goto l208
						}
						position++
						if buffer[position] != rune('s') {
							goto l208
						}
						position++
						if buffer[position] != rune('n') {
							goto l208
						}
						position++
						if buffer[position] != rune('u') {
							goto l208
						}
						position++
						if buffer[position] != rune('l') {
							goto l208
						}
						position++
						if buffer[position] != rune('l') {
							goto l208
						}
						position++
						goto l207
					l208:
						position, tokenIndex = position207, tokenIndex207
						if buffer[position] != rune('n') {
							goto l209
						}
						position++
						if buffer[position] != rune('o') {
							goto l209
						}
						position++
						if buffer[position] != rune('t') {
							goto l209
						}
						position++
						if buffer[position] != rune('n') {
							goto l209
						}
						position++
						if buffer[position] != rune('u') {
							goto l209
						}
						position++
						if buffer[position] != rune('l') {
							goto l209
						}
						position++
						if buffer[position] != rune('l') {
							goto l209
						}
						position++
						goto l207
					l209:
						position, tokenIndex = position207, tokenIndex207
						if buffer[position] != rune('i') {
							goto l210
						}
						position++
						if buffer[position] != rune('s') {
							goto l210
						}
						position++
						if !_rules[rule__]() {
							goto l210
						}
						{
							switch buffer[position] {
							case 'n':
								if buffer[position] != rune('n') {
									goto l210
								}
								position++
								if buffer[position] != rune('u') {
									goto l210
								}
								position++
								if buffer[position] != rune('l') {
									goto l210
								}
								position++
								if buffer[position] != rune('l') {
									goto l210
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l210
								}
								position++
								if buffer[position] != rune('a') {
									goto l210
								}
								position++
								if buffer[position] != rune('l') {
									goto l210
								}
								position++
								if buffer[position] != rune('s') {
									goto l210
								}
								position++
								if buffer[position] != rune('e') {
									goto l210
								}
								position++
							default:
								if buffer[position] != rune('t') {
									goto l210
								}
								position++
								if buffer[position] != rune('r') {
									goto l210
								}
								position++
								if buffer[position] != rune('u') {
									goto l210
								}
								position++
								if buffer[position] != rune('e') {
									goto l210
								}
								position++
							}
						}

						goto l207
					l210:
						position, tokenIndex = position207, tokenIndex207
						if buffer[position] != rune('i') {
							goto l204
						}
						position++
						if buffer[position] != rune('s') {
							goto l204
						}
						position++
						if !_rules[rule__]() {
							goto l204
						}
						if buffer[position] != rune('n') {
							goto l204
						}
						position++
						if buffer[position] != rune('o') {
							goto l204
						}
						position++
						if buffer[position] != rune('t') {
							goto l204
						}
						position++
						if !_rules[rule__]() {
							goto l204
						}
						{
							switch buffer[position] {
							case 'n':
								if buffer[position] != rune('n') {
									goto l204
								}
								position++
								if buffer[position] != rune('u') {
									goto l204
								}
								position++
								if buffer[position] != rune('l') {
									goto l204
								}
								position++
								if buffer[position] != rune('l') {
									goto l204
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l204
								}
								position++
								if buffer[position] != rune('a') {
									goto l204
								}
								position++
								if buffer[position] != rune('l') {
									goto l204
								}
								position++
								if buffer[position] != rune('s') {
									goto l204
								}
								position++
								if buffer[position] != rune('e') {
									goto l204
								}
								position++
							default:
								if buffer[position] != rune('t') {
									goto l204
								}
								position++
								if buffer[position] != rune('r') {
									goto l204
								}
								position++
								if buffer[position] != rune('u') {
									goto l204
								}
								position++
								if buffer[position] != rune('e') {
									goto l204
								}
								position++
							}
						}

					}
				l207:
					add(rulePegText, position206)
				}
				if !_rules[rule_]() {
					goto l204
				}
				if !_rules[ruleAction20]() {
					goto l204
				}
				add(ruleMatch, position205)
			}
			return true
		l204:
			position, tokenIndex = position204, tokenIndex204
			return false
		},
		/* 18 Value <- <(Literal / Array)> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				{
					position215, tokenIndex215 := position, tokenIndex
					if !_rules[ruleLiteral]() {
						goto l216
					}
					goto l215
				l216:
					position, tokenIndex = position215, tokenIndex215
					if !_rules[ruleArray]() {
						goto l213
					}
				}
			l215:
				add(ruleValue, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 19 Array <- <(('[' Action21 _ (Literal (_ ',' _ Literal)* _ ','?)? _ ']' Action22) / ('(' Action23 _ (Literal (_ ',' _ Literal)* _ ','?)? _ ')' Action24))> */
		func() bool {
			position217, tokenIndex217 := position, tokenIndex
			{
				position218 := position
				{
					position219, tokenIndex219 := position, tokenIndex
					if buffer[position] != rune('[') {
						goto l220
					}
					position++
					if !_rules[ruleAction21]() {
						goto l220
					}
					if !_rules[rule_]() {
						goto l220
					}
					{
						position221, tokenIndex221 := position, tokenIndex
						if !_rules[ruleLiteral]() {
							goto l221
						}
					l223:
						{
							position224, tokenIndex224 := position, tokenIndex
							if !_rules[rule_]() {
								goto l224
							}
							if buffer[position] != rune(',') {
								goto l224
							}
							position++
							if !_rules[rule_]() {
								goto l224
							}
							if !_rules[ruleLiteral]() {
								goto l224
							}
							goto l223
						l224:
							position, tokenIndex = position224, tokenIndex224
						}
						if !_rules[rule_]() {
							goto l221
						}
						{
							position225, tokenIndex225 := position, tokenIndex
							if buffer[position] != rune(',') {
								goto l225
							}
							position++
							goto l226
						l225:
							position, tokenIndex = position225, tokenIndex225
						}
					l226:
						goto l222
					l221:
						position, tokenIndex = position221, tokenIndex221
					}
				l222:
					if !_rules[rule_]() {
						goto l220
					}
					if buffer[position] != rune(']') {
						goto l220
					}
					position++
					if !_rules[ruleAction22]() {
						goto l220
					}
					goto l219
				l220:
					position, tokenIndex = position219, tokenIndex219
					if buffer[position] != rune('(') {
						goto l217
					}
					position++
					if !_rules[ruleAction23]() {
						goto l217
					}
					if !_rules[rule_]() {
						goto l217
					}
					{
						position227, tokenIndex227 := position, tokenIndex
						if !_rules[ruleLiteral]() {
							goto l227
						}
					l229:
						{
							position230, tokenIndex230 := position, tokenIndex
							if !_rules[rule_]() {
								goto l230
							}
							if buffer[position] != rune(',') {
								goto l230
							}
							position++
							if !_rules[rule_]() {
								goto l230
							}
							if !_rules[ruleLiteral]() {
								goto l230
							}
							goto l229
						l230:
							position, tokenIndex = position230, tokenIndex230
						}
						if !_rules[rule_]() {
							goto l227
						}
						{
							position231, tokenIndex231 := position, tokenIndex
							if buffer[position] != rune(',') {
								goto l231
							}
							position++
							goto l232
						l231:
							position, tokenIndex = position231, tokenIndex231
						}
					l232:
						goto l228
					l227:
						position, tokenIndex = position227, tokenIndex227
					}
				l228:
					if !_rules[rule_]() {
						goto l217
					}
					if buffer[position] != rune(')') {
						goto l217
					}
					position++
					if !_rules[ruleAction24]() {
						goto l217
					}
				}
			l219:
				add(ruleArray, position218)
			}
			return true
		l217:
			position, tokenIndex = position217, tokenIndex217
			return false
		},
		/* 20 Literal <- <((&('N' | 'n') Null) | (&('F' | 'T' | 'f' | 't') Boolean) | (&('"' | '\'') String) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') Integer))> */
		func() bool {
			position233, tokenIndex233 := position, tokenIndex
			{
				position234 := position
				{
					switch buffer[position] {
					case 'N', 'n':
						if !_rules[ruleNull]() {
							goto l233
						}
					case 'F', 'T', 'f', 't':
						if !_rules[ruleBoolean]() {
							goto l233
						}
					case '"', '\'':
						if !_rules[ruleString]() {
							goto l233
						}
					default:
						if !_rules[ruleInteger]() {
							goto l233
						}
					}
				}

				add(ruleLiteral, position234)
			}
			return true
		l233:
			position, tokenIndex = position233, tokenIndex233
			return false
		},
		/* 21 Integer <- <(<('0' / ([1-9] [0-9]*))> Action25)> */
		func() bool {
			position236, tokenIndex236 := position, tokenIndex
			{
				position237 := position
				{
					position238 := position
					{
						position239, tokenIndex239 := position, tokenIndex
						if buffer[position] != rune('0') {
							goto l240
						}
						position++
						goto l239
					l240:
						position, tokenIndex = position239, tokenIndex239
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l236
						}
						position++
					l241:
						{
							position242, tokenIndex242 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l242
							}
							position++
							goto l241
						l242:
							position, tokenIndex = position242, tokenIndex242
						}
					}
				l239:
					add(rulePegText, position238)
				}
				if !_rules[ruleAction25]() {
					goto l236
				}
				add(ruleInteger, position237)
			}
			return true
		l236:
			position, tokenIndex = position236, tokenIndex236
			return false
		},
		/* 22 Boolean <- <(<((&('F') ('F' 'A' 'L' 'S' 'E')) | (&('T') ('T' 'R' 'U' 'E')) | (&('f') ('f' 'a' 'l' 's' 'e')) | (&('t') ('t' 'r' 'u' 'e')))> Action26)> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245 := position
					{
						switch buffer[position] {
						case 'F':
							if buffer[position] != rune('F') {
								goto l243
							}
							position++
							if buffer[position] != rune('A') {
								goto l243
							}
							position++
							if buffer[position] != rune('L') {
								goto l243
							}
							position++
							if buffer[position] != rune('S') {
								goto l243
							}
							position++
							if buffer[position] != rune('E') {
								goto l243
							}
							position++
						case 'T':
							if buffer[position] != rune('T') {
								goto l243
							}
							position++
							if buffer[position] != rune('R') {
								goto l243
							}
							position++
							if buffer[position] != rune('U') {
								goto l243
							}
							position++
							if buffer[position] != rune('E') {
								goto l243
							}
							position++
						case 'f':
							if buffer[position] != rune('f') {
								goto l243
							}
							position++
							if buffer[position] != rune('a') {
								goto l243
							}
							position++
							if buffer[position] != rune('l') {
								goto l243
							}
							position++
							if buffer[position] != rune('s') {
								goto l243
							}
							position++
							if buffer[position] != rune('e') {
								goto l243
							}
							position++
						default:
							if buffer[position] != rune('t') {
								goto l243
							}
							position++
							if buffer[position] != rune('r') {
								goto l243
							}
							position++
							if buffer[position] != rune('u') {
								goto l243
							}
							position++
							if buffer[position] != rune('e') {
								goto l243
							}
							position++
						}
					}

					add(rulePegText, position245)
				}
				if !_rules[ruleAction26]() {
					goto l243
				}
				add(ruleBoolean, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 23 Null <- <(<(('n' 'u' 'l' 'l') / ('N' 'U' 'L' 'L'))> Action27)> */
		func() bool {
			position247, tokenIndex247 := position, tokenIndex
			{
				position248 := position
				{
					position249 := position
					{
						position250, tokenIndex250 := position, tokenIndex
						if buffer[position] != rune('n') {
							goto l251
						}
						position++
						if buffer[position] != rune('u') {
							goto l251
						}
						position++
						if buffer[position] != rune('l') {
							goto l251
						}
						position++
						if buffer[position] != rune('l') {
							goto l251
						}
						position++
						goto l250
					l251:
						position, tokenIndex = position250, tokenIndex250
						if buffer[position] != rune('N') {
							goto l247
						}
						position++
						if buffer[position] != rune('U') {
							goto l247
						}
						position++
						if buffer[position] != rune('L') {
							goto l247
						}
						position++
						if buffer[position] != rune('L') {
							goto l247
						}
						position++
					}
				l250:
					add(rulePegText, position249)
				}
				if !_rules[ruleAction27]() {
					goto l247
				}
				add(ruleNull, position248)
			}
			return true
		l247:
			position, tokenIndex = position247, tokenIndex247
			return false
		},
		/* 24 String <- <(('\'' <(!'\'' .)*> '\'' Action28) / ('"' <(!'"' .)*> '"' Action29))> */
		func() bool {
			position252, tokenIndex252 := position, tokenIndex
			{
				position253 := position
				{
					position254, tokenIndex254 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l255
					}
					position++
					{
						position256 := position
					l257:
						{
							position258, tokenIndex258 := position, tokenIndex
							{
								position259, tokenIndex259 := position, tokenIndex
								if buffer[position] != rune('\'') {
									goto l259
								}
								position++
								goto l258
							l259:
								position, tokenIndex = position259, tokenIndex259
							}
							if !matchDot() {
								goto l258
							}
							goto l257
						l258:
							position, tokenIndex = position258, tokenIndex258
						}
						add(rulePegText, position256)
					}
					if buffer[position] != rune('\'') {
						goto l255
					}
					position++
					if !_rules[ruleAction28]() {
						goto l255
					}
					goto l254
				l255:
					position, tokenIndex = position254, tokenIndex254
					if buffer[position] != rune('"') {
						goto l252
					}
					position++
					{
						position260 := position
					l261:
						{
							position262, tokenIndex262 := position, tokenIndex
							{
								position263, tokenIndex263 := position, tokenIndex
								if buffer[position] != rune('"') {
									goto l263
								}
								position++
								goto l262
							l263:
								position, tokenIndex = position263, tokenIndex263
							}
							if !matchDot() {
								goto l262
							}
							goto l261
						l262:
							position, tokenIndex = position262, tokenIndex262
						}
						add(rulePegText, position260)
					}
					if buffer[position] != rune('"') {
						goto l252
					}
					position++
					if !_rules[ruleAction29]() {
						goto l252
					}
				}
			l254:
				add(ruleString, position253)
			}
			return true
		l252:
			position, tokenIndex = position252, tokenIndex252
			return false
		},
		/* 25 SpaceComment <- <(Space / Comment)> */
		func() bool {
			position264, tokenIndex264 := position, tokenIndex
			{
				position265 := position
				{
					position266, tokenIndex266 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l267
					}
					goto l266
				l267:
					position, tokenIndex = position266, tokenIndex266
					if !_rules[ruleComment]() {
						goto l264
					}
				}
			l266:
				add(ruleSpaceComment, position265)
			}
			return true
		l264:
			position, tokenIndex = position264, tokenIndex264
			return false
		},
		/* 26 _ <- <SpaceComment*> */
		func() bool {
			{
				position269 := position
			l270:
				{
					position271, tokenIndex271 := position, tokenIndex
					if !_rules[ruleSpaceComment]() {
						goto l271
					}
					goto l270
				l271:
					position, tokenIndex = position271, tokenIndex271
				}
				add(rule_, position269)
			}
			return true
		},
		/* 27 __ <- <SpaceComment+> */
		func() bool {
			position272, tokenIndex272 := position, tokenIndex
			{
				position273 := position
				if !_rules[ruleSpaceComment]() {
					goto l272
				}
			l274:
				{
					position275, tokenIndex275 := position, tokenIndex
					if !_rules[ruleSpaceComment]() {
						goto l275
					}
					goto l274
				l275:
					position, tokenIndex = position275, tokenIndex275
				}
				add(rule__, position273)
			}
			return true
		l272:
			position, tokenIndex = position272, tokenIndex272
			return false
		},
		/* 28 Comment <- <((('-' '-') / ('/' '/')) (!EndOfLine .)* EndOfLine)> */
		func() bool {
			position276, tokenIndex276 := position, tokenIndex
			{
				position277 := position
				{
					position278, tokenIndex278 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l279
					}
					position++
					if buffer[position] != rune('-') {
						goto l279
					}
					position++
					goto l278
				l279:
					position, tokenIndex = position278, tokenIndex278
					if buffer[position] != rune('/') {
						goto l276
					}
					position++
					if buffer[position] != rune('/') {
						goto l276
					}
					position++
				}
			l278:
			l280:
				{
					position281, tokenIndex281 := position, tokenIndex
					{
						position282, tokenIndex282 := position, tokenIndex
						if !_rules[ruleEndOfLine]() {
							goto l282
						}
						goto l281
					l282:
						position, tokenIndex = position282, tokenIndex282
					}
					if !matchDot() {
						goto l281
					}
					goto l280
				l281:
					position, tokenIndex = position281, tokenIndex281
				}
				if !_rules[ruleEndOfLine]() {
					goto l276
				}
				add(ruleComment, position277)
			}
			return true
		l276:
			position, tokenIndex = position276, tokenIndex276
			return false
		},
		/* 29 Space <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') EndOfLine))> */
		func() bool {
			position283, tokenIndex283 := position, tokenIndex
			{
				position284 := position
				{
					switch buffer[position] {
					case '\t':
						if buffer[position] != rune('\t') {
							goto l283
						}
						position++
					case ' ':
						if buffer[position] != rune(' ') {
							goto l283
						}
						position++
					default:
						if !_rules[ruleEndOfLine]() {
							goto l283
						}
					}
				}

				add(ruleSpace, position284)
			}
			return true
		l283:
			position, tokenIndex = position283, tokenIndex283
			return false
		},
		/* 30 EndOfLine <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position286, tokenIndex286 := position, tokenIndex
			{
				position287 := position
				{
					position288, tokenIndex288 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l289
					}
					position++
					if buffer[position] != rune('\n') {
						goto l289
					}
					position++
					goto l288
				l289:
					position, tokenIndex = position288, tokenIndex288
					if buffer[position] != rune('\n') {
						goto l290
					}
					position++
					goto l288
				l290:
					position, tokenIndex = position288, tokenIndex288
					if buffer[position] != rune('\r') {
						goto l286
					}
					position++
				}
			l288:
				add(ruleEndOfLine, position287)
			}
			return true
		l286:
			position, tokenIndex = position286, tokenIndex286
			return false
		},
		/* 31 EndOfFile <- <!.> */
		func() bool {
			position291, tokenIndex291 := position, tokenIndex
			{
				position292 := position
				{
					position293, tokenIndex293 := position, tokenIndex
					if !matchDot() {
						goto l293
					}
					goto l291
				l293:
					position, tokenIndex = position293, tokenIndex293
				}
				add(ruleEndOfFile, position292)
			}
			return true
		l291:
			position, tokenIndex = position291, tokenIndex291
			return false
		},
		/* 33 Action0 <- <{p.PopLogic()}> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		/* 34 Action1 <- <{p.PopNot()}> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 35 Action2 <- <{p.PopCompare()}> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		nil,
		/* 37 Action3 <- <{p.AddCompare(text)}> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 38 Action4 <- <{p.PopCompare()}> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 39 Action5 <- <{p.PopPredicate()}> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 40 Action6 <- <{p.AddOperation(text)}> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 41 Action7 <- <{p.PopBetween()}> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 42 Action8 <- <{p.PopParentheses()}> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 43 Action9 <- <{p.PopFunction()}> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 44 Action10 <- <{p.AddMark()}> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 45 Action11 <- <{p.PopArray()}> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 46 Action12 <- <{p.AddMark()}> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 47 Action13 <- <{p.PopIdentifierReference()}> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 48 Action14 <- <{p.AddName(text)}> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 49 Action15 <- <{p.AddCompare(text)}> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 50 Action16 <- <{p.AddCompare(text)}> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 51 Action17 <- <{p.AddCompare(text)}> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 52 Action18 <- <{p.AddLogic(text)}> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 53 Action19 <- <{p.AddLogic(text)}> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 54 Action20 <- <{p.AddMatch(text)}> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 55 Action21 <- <{p.AddMark()}> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 56 Action22 <- <{p.PopArray()}> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 57 Action23 <- <{p.AddMark()}> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 58 Action24 <- <{p.PopArray()}> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 59 Action25 <- <{p.AddInteger(text)}> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 60 Action26 <- <{p.AddBoolean(text)}> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 61 Action27 <- <{p.AddNull()}> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		/* 62 Action28 <- <{p.AddString(text)}> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
		/* 63 Action29 <- <{p.AddString(text)}> */
		func() bool {
			{
				add(ruleAction29, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
